<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Order Monitor - Bitcraft Market Helper</title>
    <!-- Shared styles for enhanced UI mode -->
    <link rel="stylesheet" href="shared-styles.css" id="sharedStyles" disabled>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #4a9eff;
        }

        .subtitle {
            text-align: center;
            color: #b0b0b0;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .nav-links {
            text-align: center;
            margin-bottom: 20px;
        }

        .nav-links a {
            color: #4a9eff;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 4px;
            background-color: #2a2a2a;
            display: inline-block;
            margin: 0 5px;
        }

        .nav-links a:hover {
            background-color: #3a3a3a;
        }

        .status-bar {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-label {
            color: #b0b0b0;
            font-size: 13px;
        }

        .status-value {
            color: #4a9eff;
            font-weight: bold;
            font-size: 14px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-indicator.active {
            background-color: #4ade80;
            animation: pulse 2s infinite;
        }

        .status-indicator.error {
            background-color: #f87171;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            background-color: #4a9eff;
            color: #1a1a1a;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #6bb3ff;
        }

        .btn.secondary {
            background-color: #4a4a4a;
            color: #e0e0e0;
        }

        .btn.secondary:hover {
            background-color: #5a5a5a;
        }

        .btn:disabled {
            background-color: #3a3a3a;
            color: #6b7280;
            cursor: not-allowed;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
        }

        .panel h2 {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #4a4a4a;
            color: #4a9eff;
        }

        .market-table {
            width: 100%;
            border-collapse: collapse;
            background-color: #3a3a3a;
            border-radius: 4px;
            overflow: hidden;
        }

        .market-table thead {
            background-color: #2a2a2a;
        }

        .market-table th {
            padding: 12px;
            text-align: left;
            color: #4a9eff;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            border-bottom: 2px solid #4a4a4a;
        }

        .market-table td {
            padding: 12px;
            color: #e0e0e0;
            border-bottom: 1px solid #4a4a4a;
            font-size: 14px;
        }

        .market-table tbody tr {
            transition: background-color 0.2s;
            cursor: pointer;
        }

        .market-table tbody tr:hover {
            background-color: #4a4a4a;
        }

        .market-table tbody tr.highlighted {
            animation: highlight 2s ease-out;
        }

        @keyframes highlight {
            0% { background-color: #4a9eff; }
            100% { background-color: transparent; }
        }

        .change-indicator {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
        }

        .change-indicator.positive {
            background-color: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .change-indicator.negative {
            background-color: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }

        .change-indicator.new {
            background-color: rgba(167, 139, 250, 0.2);
            color: #a78bfa;
        }

        .change-log {
            max-height: 600px;
            overflow-y: auto;
        }

        .change-entry {
            background-color: #2a2a2a;
            padding: 14px;
            margin-bottom: 12px;
            border-radius: 6px;
            border: 1px solid #3a3a3a;
            border-left: 4px solid #4a4a4a;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .change-entry:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .change-entry.new-item {
            border-left-color: #a78bfa;
            background-color: rgba(167, 139, 250, 0.05);
        }

        .change-entry.order-increase {
            border-left-color: #4ade80;
            background-color: rgba(74, 222, 128, 0.05);
        }

        .change-entry.order-decrease {
            border-left-color: #f87171;
            background-color: rgba(248, 113, 113, 0.05);
        }

        .change-entry.item-removed {
            border-left-color: #fb923c;
            background-color: rgba(251, 146, 60, 0.05);
        }

        .change-entry.order-change {
            border-left-color: #60a5fa;
            background-color: rgba(96, 165, 250, 0.05);
        }

        .change-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        .change-timestamp {
            color: #808080;
            font-size: 11px;
            white-space: nowrap;
            margin-top: 2px;
        }

        .change-main-info {
            flex: 1;
            min-width: 0;
        }

        .change-item-name {
            color: #4a9eff;
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .change-item-link {
            color: #4a9eff;
            text-decoration: none;
            transition: color 0.2s;
        }

        .change-item-link:hover {
            color: #6bb3ff;
            text-decoration: underline;
        }

        .change-item-meta {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }

        .item-tier-badge {
            display: inline-block;
            padding: 2px 7px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 700;
            background-color: rgba(74, 158, 255, 0.2);
            color: #4a9eff;
        }

        .item-rarity-badge {
            display: inline-block;
            padding: 2px 7px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
        }

        .item-rarity-badge.common {
            background-color: rgba(156, 163, 175, 0.2);
            color: #9ca3af;
        }

        .item-rarity-badge.uncommon {
            background-color: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }

        .item-rarity-badge.rare {
            background-color: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        .item-rarity-badge.epic {
            background-color: rgba(168, 85, 247, 0.2);
            color: #a855f7;
        }

        .item-rarity-badge.legendary {
            background-color: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .item-rarity-badge.mythic {
            background-color: rgba(244, 63, 94, 0.2);
            color: #f43f5e;
        }

        .change-details {
            color: #e0e0e0;
            font-size: 13px;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .change-summary {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .change-type-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .change-type-badge.new {
            background-color: rgba(167, 139, 250, 0.25);
            color: #c4b5fd;
        }

        .change-type-badge.updated {
            background-color: rgba(96, 165, 250, 0.25);
            color: #93c5fd;
        }

        .change-type-badge.removed {
            background-color: rgba(248, 113, 113, 0.25);
            color: #fca5a5;
        }

        .change-delta {
            font-size: 12px;
            color: #b0b0b0;
        }

        .change-delta.positive {
            color: #4ade80;
        }

        .change-delta.negative {
            color: #f87171;
        }

        .change-order-info {
            display: flex;
            gap: 8px;
            margin-top: 6px;
            flex-wrap: wrap;
        }

        .order-type-badge,
        .action-badge,
        .claim-badge,
        .owner-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
        }

        .order-type-badge.sell {
            background-color: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }

        .order-type-badge.buy {
            background-color: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .action-badge.added {
            background-color: rgba(74, 222, 128, 0.15);
            color: #4ade80;
        }

        .action-badge.removed {
            background-color: rgba(248, 113, 113, 0.15);
            color: #f87171;
        }

        .claim-badge {
            background-color: rgba(74, 158, 255, 0.15);
            color: #4a9eff;
        }

        .owner-badge {
            background-color: rgba(176, 176, 176, 0.15);
            color: #b0b0b0;
        }

        .change-order-details {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #3a3a3a;
        }

        .individual-order {
            padding: 10px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #e0e0e0;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border-left: 3px solid #4a4a4a;
            transition: background-color 0.2s;
        }

        .individual-order:last-child {
            margin-bottom: 0;
        }

        .individual-order:hover {
            background-color: rgba(0, 0, 0, 0.3);
        }

        .individual-order.sell-order {
            border-left-color: #f87171;
        }

        .individual-order.buy-order {
            border-left-color: #4ade80;
        }

        .order-primary-info {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 6px;
            flex-wrap: wrap;
        }

        .order-price-info {
            display: flex;
            gap: 12px;
            font-size: 11px;
            color: #b0b0b0;
        }

        .order-price-highlight {
            color: #fbbf24;
            font-weight: 600;
        }

        .order-qty-highlight {
            color: #e0e0e0;
            font-weight: 500;
        }

        .loading {
            text-align: center;
            color: #b0b0b0;
            padding: 40px;
            font-style: italic;
        }

        .error-message {
            background-color: #4a2a2a;
            color: #f87171;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #f87171;
            margin-bottom: 20px;
        }

        .empty-state {
            text-align: center;
            color: #b0b0b0;
            padding: 40px;
            font-style: italic;
        }

        .attribution-footer {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 40px;
            text-align: center;
            border-top: 2px solid #4a9eff;
        }

        .attribution-footer p {
            color: #b0b0b0;
            font-size: 14px;
            margin: 0;
        }

        .attribution-footer a {
            color: #4a9eff;
            text-decoration: none;
            font-weight: 600;
        }

        .attribution-footer a:hover {
            color: #6bb3ff;
            text-decoration: underline;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .status-bar {
                flex-direction: column;
                align-items: flex-start;
            }

            .controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }

        /* Claim Filter Styles */
        .claim-filter-container {
            position: relative;
            flex: 1;
            min-width: 250px;
            max-width: 400px;
        }

        .claim-filter-label {
            color: #b0b0b0;
            font-size: 12px;
            margin-bottom: 4px;
            display: block;
        }

        .claim-filter-input {
            width: 100%;
            padding: 10px 12px;
            background-color: #3a3a3a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .claim-filter-input:focus {
            border-color: #4a9eff;
        }

        .claim-filter-input::placeholder {
            color: #808080;
        }

        .claim-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: #3a3a3a;
            border: 1px solid #4a4a4a;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .claim-dropdown.show {
            display: block;
        }

        .claim-dropdown-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #4a4a4a;
            transition: background-color 0.2s;
        }

        .claim-dropdown-item:last-child {
            border-bottom: none;
        }

        .claim-dropdown-item:hover,
        .claim-dropdown-item.selected {
            background-color: #4a4a4a;
        }

        .claim-dropdown-item.all-claims {
            color: #4a9eff;
            font-weight: 500;
        }

        .claim-dropdown-item .claim-name {
            color: #e0e0e0;
        }

        .claim-dropdown-item .claim-orders {
            color: #808080;
            font-size: 12px;
            margin-left: 8px;
        }

        .claim-filter-clear {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #808080;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            line-height: 1;
            margin-top: 8px;
        }

        .claim-filter-clear:hover {
            color: #e0e0e0;
        }

        .active-filter {
            background-color: #3a4a5a;
            padding: 6px 12px;
            border-radius: 4px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #4a9eff;
        }

        .active-filter .remove-filter {
            cursor: pointer;
            color: #808080;
        }

        .active-filter .remove-filter:hover {
            color: #f87171;
        }

        /* Claim-grouped order display */
        .claim-section {
            background-color: #3a3a3a;
            border-radius: 8px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .claim-header {
            background-color: #2a2a2a;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #4a4a4a;
        }

        .claim-header:hover {
            background-color: #353535;
        }

        .claim-header .claim-name {
            color: #4a9eff;
            font-weight: 700;
            font-size: 17px;
        }

        .claim-header .claim-stats {
            display: flex;
            gap: 15px;
            font-size: 13px;
        }

        .claim-header .claim-stats .sell-count {
            color: #f87171;
        }

        .claim-header .claim-stats .buy-count {
            color: #4ade80;
        }

        .claim-orders {
            padding: 10px 15px;
        }

        .claim-orders.collapsed {
            display: none;
        }

        .order-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #4a4a4a;
            font-size: 13px;
        }

        .order-row:last-child {
            border-bottom: none;
        }

        .order-row:hover {
            background-color: #454545;
        }

        .order-row .order-item-name {
            color: #e0e0e0;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .order-row .order-item-name a {
            color: #4a9eff;
            text-decoration: none;
        }

        .order-row .order-item-name a:hover {
            text-decoration: underline;
        }

        .order-row .order-type {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            margin-right: 10px;
        }

        .order-row .order-type.sell {
            background-color: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }

        .order-row .order-type.buy {
            background-color: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }

        .order-row .order-qty {
            color: #b0b0b0;
            margin-right: 15px;
            min-width: 80px;
        }

        .order-row .order-price {
            color: #fbbf24;
            font-weight: 500;
            min-width: 80px;
            text-align: right;
        }

        .order-row .order-metadata {
            display: flex;
            gap: 8px;
            font-size: 11px;
            color: #b0b0b0;
            margin-left: 8px;
        }

        .order-row .metadata-badge {
            padding: 2px 6px;
            border-radius: 3px;
            background-color: rgba(74, 74, 74, 0.3);
            white-space: nowrap;
        }

        .order-row .metadata-badge.tier {
            background-color: rgba(74, 158, 255, 0.15);
            color: #4a9eff;
        }

        .order-row .metadata-badge.rarity {
            background-color: rgba(167, 139, 250, 0.15);
            color: #a78bfa;
        }

        .order-row .metadata-badge.category {
            background-color: rgba(251, 191, 36, 0.15);
            color: #fbbf24;
        }

        .item-filter-container {
            margin-bottom: 15px;
            position: relative;
        }

        .item-filter-input {
            width: 100%;
            padding: 10px 12px;
            background-color: #3a3a3a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .item-filter-input:focus {
            border-color: #4a9eff;
        }

        .item-filter-input::placeholder {
            color: #808080;
        }

        .item-filter-clear {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #808080;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            line-height: 1;
        }

        .item-filter-clear:hover {
            color: #e0e0e0;
        }

        .view-toggle {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .view-toggle button {
            padding: 8px 16px;
            background-color: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #b0b0b0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .view-toggle button:hover {
            background-color: #4a4a4a;
        }

        .view-toggle button.active {
            background-color: #4a9eff;
            color: #1a1a1a;
            border-color: #4a9eff;
        }

        .orders-container {
            max-height: 600px;
            overflow-y: auto;
        }

        .no-orders-message {
            text-align: center;
            color: #808080;
            padding: 40px;
            font-style: italic;
        }

        /* Order type filter checkboxes */
        .order-type-filters {
            display: flex;
            gap: 15px;
            align-items: center;
            padding: 10px 15px;
            background-color: #3a3a3a;
            border-radius: 4px;
        }

        .order-type-filters label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            color: #e0e0e0;
            font-size: 13px;
            user-select: none;
        }

        .order-type-filters input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #4a9eff;
        }

        .order-type-filters .filter-label {
            color: #b0b0b0;
            font-size: 12px;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Market Order Monitor</h1>
        <div class="subtitle">Real-time tracking of market order changes ‚Ä¢ Updates every minute</div>

        <div class="nav-links">
            <a href="dashboard.html">üìä Dashboard</a>
            <a href="index.html">‚Üê Back to Market Helper</a>
            <a href="gear-finder.html">‚öîÔ∏è Gear Finder</a>
            <a href="help.html">üìö Help & FAQ</a>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <span class="status-indicator" id="statusIndicator"></span>
                <span class="status-label">Status:</span>
                <span class="status-value" id="statusText">Initializing...</span>
            </div>
            <div class="status-item">
                <span class="status-label">Last Update:</span>
                <span class="status-value" id="lastUpdateText">-</span>
            </div>
            <div class="status-item">
                <span class="status-label">Total Changes:</span>
                <span class="status-value" id="totalChanges">-</span>
            </div>
            <div class="status-item">
                <span class="status-label">Items with Orders:</span>
                <span class="status-value" id="itemCount">-</span>
            </div>
        </div>

        <div class="controls">
            <button class="btn" id="refreshBtn" onclick="refreshData()">üîÑ Refresh Now</button>
            <button class="btn secondary" id="pauseBtn" onclick="togglePause()">‚è∏Ô∏è Pause Auto-Refresh</button>
            <button class="btn secondary" onclick="clearHighlights()">‚ú® Clear Highlights</button>

            <div class="claim-filter-container">
                <label class="claim-filter-label">Filter by Claim</label>
                <input type="text"
                       class="claim-filter-input"
                       id="claimFilterInput"
                       placeholder="Type to search claims..."
                       autocomplete="off">
                <button class="claim-filter-clear" id="claimFilterClear" onclick="clearClaimFilter()" style="display: none;">‚úï</button>
                <div class="claim-dropdown" id="claimDropdown"></div>
            </div>

            <div class="order-type-filters">
                <span class="filter-label">Show:</span>
                <label>
                    <input type="checkbox" id="showBuyOrders" checked onchange="applyOrderTypeFilter()">
                    Buy Orders
                </label>
                <label>
                    <input type="checkbox" id="showSellOrders" checked onchange="applyOrderTypeFilter()">
                    Sell Orders
                </label>
            </div>

            <div class="order-type-filters">
                <span class="filter-label">Min Hex:</span>
                <input type="number"
                       id="minHexFilter"
                       placeholder="0"
                       min="0"
                       step="1"
                       style="width: 120px; padding: 8px; background-color: #3a3a3a; border: 1px solid #4a4a4a; border-radius: 4px; color: #e0e0e0; font-size: 13px;"
                       oninput="applyMinHexFilter()">
                <button class="claim-filter-clear" id="minHexClear" onclick="clearMinHexFilter()" style="display: none; position: static; transform: none; margin: 0 0 0 5px;">‚úï</button>
            </div>

            <div class="order-type-filters" style="position: relative;">
                <span class="filter-label">Tier:</span>
                <button class="btn secondary" id="tierFilterBtn" onclick="toggleTierDropdown()" style="padding: 8px 16px; font-size: 13px;">
                    <span id="tierFilterLabel">All Tiers</span> ‚ñº
                </button>
                <div class="claim-dropdown" id="tierDropdown" style="display: none; position: absolute; top: 100%; left: 0; z-index: 200; width: 250px; margin-top: 5px;">
                    <div style="padding: 10px;">
                        <label style="display: block; margin-bottom: 8px; cursor: pointer; color: #e0e0e0;">
                            <input type="checkbox" id="tierAll" checked onchange="toggleAllTiers()" style="margin-right: 6px;">
                            All Tiers
                        </label>
                        <div id="tierCheckboxes" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; padding-top: 8px; border-top: 1px solid #4a4a4a;">
                        </div>
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #4a4a4a; display: flex; gap: 8px;">
                            <button class="btn secondary" onclick="clearTierFilter()" style="flex: 1; padding: 6px; font-size: 12px;">Clear</button>
                            <button class="btn" onclick="applyTierFilter()" style="flex: 1; padding: 6px; font-size: 12px;">Apply</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="order-type-filters" style="position: relative;">
                <span class="filter-label">Category:</span>
                <select id="categoryFilter" onchange="applyCategoryFilter()" style="width: 180px; padding: 8px; background-color: #3a3a3a; border: 1px solid #4a4a4a; border-radius: 4px; color: #e0e0e0; font-size: 13px; cursor: pointer;">
                    <option value="">All Categories</option>
                </select>
            </div>
        </div>

        <div id="errorContainer"></div>

        <div class="main-grid">
            <div class="panel">
                <h2>üìà Current Market Orders</h2>
                <div class="item-filter-container">
                    <input type="text"
                           class="item-filter-input"
                           id="itemFilterInput"
                           placeholder="Filter by item name or category..."
                           autocomplete="off"
                           oninput="applyItemFilter()">
                    <button class="item-filter-clear" id="itemFilterClear" onclick="clearItemFilter()" style="display: none;">‚úï</button>
                </div>
                <div class="view-toggle">
                    <button id="viewByClaimBtn" class="active" onclick="setViewMode('claim')">By Claim</button>
                    <button id="viewByItemBtn" onclick="setViewMode('item')">By Item</button>
                </div>
                <div class="orders-container" id="ordersContainer">
                    <div class="loading">Loading market data...</div>
                </div>
            </div>

            <div class="panel">
                <h2>üìã Recent Changes</h2>
                <div class="change-log" id="changeLog">
                    <div class="loading">Loading change history...</div>
                </div>
            </div>
        </div>

        <div class="attribution-footer">
            <p>Market data graciously provided by <a href="https://bitjita.com" target="_blank">bitjita.com</a> üíô</p>
        </div>
    </div>

    <!-- UI Version Toggle -->
    <div class="version-toggle" id="versionToggle" style="position: fixed; bottom: 20px; left: 20px; z-index: 1000; background-color: #2a2a2a; padding: 8px 15px; border-radius: 6px; border: 1px solid #4a4a4a; display: flex; align-items: center; gap: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.3);">
        <label style="margin: 0; font-size: 12px; color: #b0b0b0; cursor: pointer; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="uiVersionToggle" style="width: 16px; height: 16px; cursor: pointer;">
            Enhanced UI
        </label>
    </div>

    <script src="shared-utils.js"></script>
    <script>
        // ==========================================
        // CONFIGURATION
        // ==========================================
        // Supabase configuration - REPLACE THESE WITH YOUR OWN VALUES
        const SUPABASE_URL = 'https://oruszpmuvraxkzwlayex.supabase.co'; // e.g., https://your-project.supabase.co
        const SUPABASE_ANON_KEY = 'sb_publishable__WY2P7UF9lb_HQjYLyUa_A_sT8JyW-Y';
        const REFRESH_INTERVAL = 60000; // 1 minute (poll for changes)

        // ==========================================
        // STATE
        // ==========================================
        let isPaused = false;
        let refreshTimer = null;
        let currentState = null;
        let previousItems = new Map();
        let allClaims = new Map(); // Map of claimName -> { claimEntityId, orderCount }
        let selectedClaim = null; // Currently selected claim filter
        let lastChangesData = null; // Store changes data for filtering
        let currentOrderDetails = {}; // Current order details from state endpoint
        let viewMode = 'claim'; // 'claim' or 'item'
        let claimOrdersMap = new Map(); // Map of claimName -> { orders: [], sellCount, buyCount }
        let selectedTiers = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]); // All tiers selected by default
        let selectedCategory = ''; // Empty string means all categories
        let availableCategories = new Set(); // Categories from current orders
        let itemSortColumn = 'tier'; // Default sort column for item view
        let itemSortDirection = 'asc'; // 'asc' or 'desc'

        // ==========================================
        // INITIALIZATION
        // ==========================================
        async function init() {
            initClaimFilter();
            initTierFilter();
            await refreshData();
            startAutoRefresh();
        }

        function initTierFilter() {
            const container = document.getElementById('tierCheckboxes');
            let html = '';
            for (let i = 1; i <= 10; i++) {
                html += `
                    <label style="display: flex; align-items: center; cursor: pointer; color: #e0e0e0;">
                        <input type="checkbox" class="tier-checkbox" value="${i}" checked onchange="updateTierSelection()" style="margin-right: 6px;">
                        Tier ${i}
                    </label>
                `;
            }
            container.innerHTML = html;

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#tierFilterBtn') && !e.target.closest('#tierDropdown')) {
                    document.getElementById('tierDropdown').style.display = 'none';
                }
            });
        }

        // ==========================================
        // AUTO REFRESH
        // ==========================================
        function startAutoRefresh() {
            if (refreshTimer) {
                clearInterval(refreshTimer);
            }

            refreshTimer = setInterval(() => {
                if (!isPaused) {
                    refreshData();
                }
            }, REFRESH_INTERVAL);
        }

        function togglePause() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');

            if (isPaused) {
                btn.textContent = '‚ñ∂Ô∏è Resume Auto-Refresh';
                updateStatus('Paused', 'error');
            } else {
                btn.textContent = '‚è∏Ô∏è Pause Auto-Refresh';
                updateStatus('Active', 'active');
                refreshData();
            }
        }

        // ==========================================
        // SUPABASE HELPERS
        // ==========================================
        async function supabaseQuery(table, select = '*', filter = '', limit = null) {
            let url = `${SUPABASE_URL}/rest/v1/${table}?select=${select}`;
            if (filter) url += `&${filter}`;
            if (limit) url += `&limit=${limit}`;

            const response = await fetch(url, {
                headers: {
                    'apikey': SUPABASE_ANON_KEY,
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                }
            });

            if (!response.ok) {
                throw new Error(`Supabase query failed: ${response.status}`);
            }

            return response.json();
        }

        /**
         * Fetch all rows from a table using pagination
         * Supabase has a max limit of 1000 rows per request
         */
        async function supabaseQueryAll(table, select = '*', filter = '', orderBy = '') {
            const BATCH_SIZE = 1000;
            let allResults = [];
            let offset = 0;
            let hasMore = true;

            while (hasMore) {
                let url = `${SUPABASE_URL}/rest/v1/${table}?select=${select}`;
                if (filter) url += `&${filter}`;
                if (orderBy) url += `&order=${orderBy}`;
                url += `&limit=${BATCH_SIZE}&offset=${offset}`;

                const response = await fetch(url, {
                    headers: {
                        'apikey': SUPABASE_ANON_KEY,
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`Supabase query failed: ${response.status}`);
                }

                const batch = await response.json();
                allResults = allResults.concat(batch);

                // If we got fewer than BATCH_SIZE results, we've reached the end
                if (batch.length < BATCH_SIZE) {
                    hasMore = false;
                } else {
                    offset += BATCH_SIZE;
                }
            }

            return allResults;
        }

        async function getMarketState() {
            // Fetch ALL market items using pagination (no 1000 row limit)
            const items = await supabaseQueryAll('market_items', '*', '', 'last_updated.desc');

            // Fetch ALL order details using pagination (no 1000 row limit)
            const orderDetailsArray = await supabaseQueryAll('order_details', '*');

            // Convert order details array to object keyed by item_id
            const orderDetails = {};
            orderDetailsArray.forEach(detail => {
                orderDetails[detail.item_id] = {
                    sellOrders: detail.sell_orders,
                    buyOrders: detail.buy_orders,
                    stats: detail.stats
                };
            });

            // Fetch metadata
            const metadata = await supabaseQuery('monitor_metadata', '*');
            const metaObj = {};
            metadata.forEach(m => { metaObj[m.key] = m.value; });

            // Convert to expected format
            const currentState = {
                items: items.map(item => ({
                    id: item.item_id,
                    name: item.item_name,
                    itemType: item.item_type,
                    tier: item.tier || 0,
                    rarity: item.rarity || '',
                    rarityStr: item.rarity || '',
                    category: item.category || '',
                    tag: item.category || '',
                    sellOrders: item.sell_orders,
                    buyOrders: item.buy_orders,
                    totalOrders: item.total_orders
                })),
                fetchedAt: metaObj.last_update || Date.now()
            };

            return {
                currentState,
                orderDetails,
                lastUpdate: metaObj.last_update,
                changeCount: metaObj.change_count || 0,
                timestamp: Date.now()
            };
        }

        async function getChanges(limit = 50) {
            const changes = await supabaseQuery('market_changes', '*', 'order=timestamp.desc', limit);
            return {
                changes: changes.reverse(), // Reverse to show oldest first
                total: changes.length,
                timestamp: Date.now()
            };
        }

        // ==========================================
        // DATA FETCHING
        // ==========================================
        async function refreshData() {
            try {
                document.getElementById('refreshBtn').disabled = true;

                // Fetch current state from Supabase
                const stateData = await getMarketState();

                // Fetch recent changes from Supabase
                const changesData = await getChanges(50);

                // Store for filtering and extract claims
                currentState = stateData.currentState;
                currentOrderDetails = stateData.orderDetails || {};
                lastChangesData = changesData;
                extractClaimsFromOrderDetails(currentOrderDetails);
                countClaimOrdersFromDetails(currentOrderDetails);

                // Update UI
                updateMarketTable(stateData);
                updateChangeLog(changesData);
                updateStatusBar(stateData);
                clearError();

                if (!isPaused) {
                    updateStatus('Active', 'active');
                }

            } catch (error) {
                console.error('Error refreshing data:', error);
                showError(error.message);
                updateStatus('Error', 'error');
            } finally {
                document.getElementById('refreshBtn').disabled = false;
            }
        }

        // triggerWorkerUpdate function removed - no longer needed with Supabase
        // Data is updated by local-monitor.js running on your machine

        // ==========================================
        // UI UPDATES
        // ==========================================
        function updateMarketTable(data) {
            const container = document.getElementById('ordersContainer');

            // Build claim orders map from changes data
            buildClaimOrdersMap();

            // Populate category filter with available categories
            populateCategoryFilter();

            if (viewMode === 'claim') {
                renderClaimView(container);
            } else {
                renderItemView(container, data);
            }
        }

        function buildClaimOrdersMap() {
            claimOrdersMap.clear();

            // Use current order details from state endpoint
            if (!currentOrderDetails || Object.keys(currentOrderDetails).length === 0) return;

            // Build item data map from currentState.items
            const itemData = new Map();
            if (currentState && currentState.items) {
                currentState.items.forEach(item => {
                    // Use both numeric and string keys to ensure we can find items
                    const itemKey = typeof item.id === 'number' ? item.id : parseInt(item.id);
                    itemData.set(itemKey, {
                        name: item.name,
                        tier: item.tier,
                        rarity: item.rarityStr || item.rarity,
                        category: item.tag || item.category || 'Unknown'
                    });
                });
            }

            // Group orders by claim, then by item+price
            Object.entries(currentOrderDetails).forEach(([itemId, orderDetails]) => {
                const itemIdNum = typeof itemId === 'number' ? itemId : parseInt(itemId);
                const item = itemData.get(itemIdNum) || {
                    name: `Item ${itemId}`,
                    tier: 0,
                    rarity: 'Unknown',
                    category: 'Unknown'
                };

                // Process sell orders
                (orderDetails.sellOrders || []).forEach(order => {
                    const claimName = order.claimName || 'Unknown Claim';
                    if (!claimOrdersMap.has(claimName)) {
                        claimOrdersMap.set(claimName, { orderGroups: new Map(), sellCount: 0, buyCount: 0 });
                    }
                    const claimData = claimOrdersMap.get(claimName);

                    // Group by item + price + type
                    const orderKey = `sell_${itemId}_${order.priceThreshold}`;
                    if (!claimData.orderGroups.has(orderKey)) {
                        claimData.orderGroups.set(orderKey, {
                            type: 'sell',
                            itemId,
                            itemName: item.name,
                            tier: item.tier,
                            rarity: item.rarity,
                            category: item.category,
                            price: order.priceThreshold,
                            quantity: 0,
                            ownerNames: new Set()
                        });
                    }
                    const group = claimData.orderGroups.get(orderKey);
                    group.quantity += order.quantity;
                    group.ownerNames.add(order.ownerName || 'Unknown');
                    claimData.sellCount++;
                });

                // Process buy orders
                (orderDetails.buyOrders || []).forEach(order => {
                    const claimName = order.claimName || 'Unknown Claim';
                    if (!claimOrdersMap.has(claimName)) {
                        claimOrdersMap.set(claimName, { orderGroups: new Map(), sellCount: 0, buyCount: 0 });
                    }
                    const claimData = claimOrdersMap.get(claimName);

                    // Group by item + price + type
                    const orderKey = `buy_${itemId}_${order.priceThreshold}`;
                    if (!claimData.orderGroups.has(orderKey)) {
                        claimData.orderGroups.set(orderKey, {
                            type: 'buy',
                            itemId,
                            itemName: item.name,
                            tier: item.tier,
                            rarity: item.rarity,
                            category: item.category,
                            price: order.priceThreshold,
                            quantity: 0,
                            ownerNames: new Set()
                        });
                    }
                    const group = claimData.orderGroups.get(orderKey);
                    group.quantity += order.quantity;
                    group.ownerNames.add(order.ownerName || 'Unknown');
                    claimData.buyCount++;
                });
            });
        }

        function renderClaimView(container) {
            // Get order type filters
            const showBuyOrders = document.getElementById('showBuyOrders')?.checked ?? true;
            const showSellOrders = document.getElementById('showSellOrders')?.checked ?? true;

            // Get item filter
            const itemFilter = document.getElementById('itemFilterInput')?.value.toLowerCase() || '';

            // Get minimum hex filter
            const minHexInput = document.getElementById('minHexFilter')?.value || '';
            const minHex = minHexInput ? parseFloat(minHexInput) : 0;

            // Filter by selected claim if applicable
            let claimsToRender = Array.from(claimOrdersMap.entries());

            if (selectedClaim) {
                claimsToRender = claimsToRender.filter(([name]) => name === selectedClaim);
            }

            // Sort by total orders descending
            claimsToRender.sort((a, b) => b[1].orderGroups.size - a[1].orderGroups.size);

            if (claimsToRender.length === 0) {
                container.innerHTML = '<div class="no-orders-message">No orders found. Orders will appear here when the monitor detects market activity.</div>';
                return;
            }

            const html = claimsToRender.map(([claimName, claimData]) => {
                const ordersHtml = Array.from(claimData.orderGroups.values())
                    .filter(group => {
                        // Apply order type filter
                        if (group.type === 'buy' && !showBuyOrders) return false;
                        if (group.type === 'sell' && !showSellOrders) return false;

                        // Apply minimum hex filter
                        if (minHex > 0 && group.price < minHex) return false;

                        // Apply tier filter
                        if (group.tier && !selectedTiers.has(group.tier)) return false;

                        // Apply category filter
                        if (selectedCategory && group.category !== selectedCategory) return false;

                        // Apply item name/category filter
                        if (itemFilter) {
                            const itemNameMatch = group.itemName.toLowerCase().includes(itemFilter);
                            const categoryMatch = group.category?.toLowerCase().includes(itemFilter);
                            if (!itemNameMatch && !categoryMatch) return false;
                        }

                        return true;
                    })
                    .sort((a, b) => a.itemName.localeCompare(b.itemName))
                    .map(group => {
                        const ownerCount = group.ownerNames.size;
                        const ownerLabel = group.type === 'sell' ? 'sellers' : 'buyers';

                        return `
                            <div class="order-row">
                                <span class="order-type ${group.type}">${group.type.toUpperCase()}</span>
                                <span class="order-item-name">
                                    <a href="https://bitjita.com/market/item/${group.itemId}" target="_blank">${escapeHtml(group.itemName)}</a>
                                    <span class="order-metadata">
                                        ${group.tier ? `<span class="metadata-badge tier">T${group.tier}</span>` : ''}
                                        ${group.rarity ? `<span class="metadata-badge rarity">${escapeHtml(group.rarity)}</span>` : ''}
                                        ${group.category ? `<span class="metadata-badge category">${escapeHtml(group.category)}</span>` : ''}
                                    </span>
                                </span>
                                <span class="order-qty">Qty: ${Number(group.quantity).toLocaleString()} (${ownerCount} ${ownerLabel})</span>
                                <span class="order-price">${Number(group.price).toLocaleString()} hex</span>
                            </div>
                        `;
                    }).join('');

                // Calculate filtered counts
                const filteredGroups = Array.from(claimData.orderGroups.values()).filter(group => {
                    if (group.type === 'buy' && !showBuyOrders) return false;
                    if (group.type === 'sell' && !showSellOrders) return false;

                    // Apply minimum hex filter
                    if (minHex > 0 && group.price < minHex) return false;

                    // Apply tier filter
                    if (group.tier && !selectedTiers.has(group.tier)) return false;

                    // Apply category filter
                    if (selectedCategory && group.category !== selectedCategory) return false;

                    // Apply item name/category filter
                    if (itemFilter) {
                        const itemNameMatch = group.itemName.toLowerCase().includes(itemFilter);
                        const categoryMatch = group.category?.toLowerCase().includes(itemFilter);
                        if (!itemNameMatch && !categoryMatch) return false;
                    }

                    return true;
                });
                const filteredSellCount = filteredGroups.filter(g => g.type === 'sell').length;
                const filteredBuyCount = filteredGroups.filter(g => g.type === 'buy').length;

                // Skip claims with no visible orders after filtering
                if (ordersHtml.trim() === '') return '';

                return `
                    <div class="claim-section">
                        <div class="claim-header" onclick="toggleClaimSection(this)">
                            <span class="claim-name">${escapeHtml(claimName)}</span>
                            <span class="claim-stats">
                                ${showSellOrders ? `<span class="sell-count">${filteredSellCount} sell</span>` : ''}
                                ${showBuyOrders ? `<span class="buy-count">${filteredBuyCount} buy</span>` : ''}
                            </span>
                        </div>
                        <div class="claim-orders">
                            ${ordersHtml}
                        </div>
                    </div>
                `;
            }).filter(html => html !== '').join('');

            if (html === '') {
                container.innerHTML = '<div class="no-orders-message">No orders match the current filters.</div>';
            } else {
                container.innerHTML = html;
            }
        }

        function renderItemView(container, data) {
            if (!data.currentState || !data.currentState.items || data.currentState.items.length === 0) {
                container.innerHTML = '<div class="no-orders-message">No items with orders found. Market monitoring will start on next update cycle.</div>';
                return;
            }

            // Get order type filters
            const showBuyOrders = document.getElementById('showBuyOrders')?.checked ?? true;
            const showSellOrders = document.getElementById('showSellOrders')?.checked ?? true;

            // Get item filter
            const itemFilter = document.getElementById('itemFilterInput')?.value.toLowerCase() || '';

            // Get minimum hex filter
            const minHexInput = document.getElementById('minHexFilter')?.value || '';
            const minHex = minHexInput ? parseFloat(minHexInput) : 0;

            // Apply filters to items
            const items = [...data.currentState.items].filter(item => {
                // Apply tier filter
                if (item.tier && !selectedTiers.has(item.tier)) return false;

                // Apply category filter
                const itemCategory = item.tag || item.category || 'Unknown';
                if (selectedCategory && itemCategory !== selectedCategory) return false;

                // Apply item name/category filter
                if (itemFilter) {
                    const itemNameMatch = item.name.toLowerCase().includes(itemFilter);
                    const categoryMatch = itemCategory.toLowerCase().includes(itemFilter);
                    if (!itemNameMatch && !categoryMatch) return false;
                }

                // Get order details for filtering by price and order type
                const orderDetails = currentOrderDetails && currentOrderDetails[item.id];
                if (!orderDetails) return false;

                // Apply minimum hex filter - check if any order meets the threshold
                if (minHex > 0) {
                    const hasSellAboveMin = showSellOrders && orderDetails.sellOrders?.some(order => order.priceThreshold >= minHex);
                    const hasBuyAboveMin = showBuyOrders && orderDetails.buyOrders?.some(order => order.priceThreshold >= minHex);
                    if (!hasSellAboveMin && !hasBuyAboveMin) return false;
                }

                // Apply order type filter - check if item has the requested order types
                const hasSellOrders = orderDetails.sellOrders && orderDetails.sellOrders.length > 0;
                const hasBuyOrders = orderDetails.buyOrders && orderDetails.buyOrders.length > 0;

                if (!showSellOrders && !showBuyOrders) return false;
                if (!showSellOrders && !hasBuyOrders) return false;
                if (!showBuyOrders && !hasSellOrders) return false;

                return true;
            });

            // Sort items based on current sort column and direction
            items.sort((a, b) => {
                let aVal, bVal;

                // Get order details for price comparisons
                const aOrderDetails = currentOrderDetails && currentOrderDetails[a.id];
                const bOrderDetails = currentOrderDetails && currentOrderDetails[b.id];

                switch (itemSortColumn) {
                    case 'name':
                        aVal = a.name.toLowerCase();
                        bVal = b.name.toLowerCase();
                        break;
                    case 'tier':
                        aVal = a.tier || 0;
                        bVal = b.tier || 0;
                        // Secondary sort by name for same tier
                        if (aVal === bVal) {
                            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
                        }
                        break;
                    case 'category':
                        aVal = (a.tag || a.category || 'Unknown').toLowerCase();
                        bVal = (b.tag || b.category || 'Unknown').toLowerCase();
                        break;
                    case 'lowestSell':
                        aVal = aOrderDetails?.sellOrders?.length > 0
                            ? Math.min(...aOrderDetails.sellOrders.map(o => o.priceThreshold))
                            : Infinity;
                        bVal = bOrderDetails?.sellOrders?.length > 0
                            ? Math.min(...bOrderDetails.sellOrders.map(o => o.priceThreshold))
                            : Infinity;
                        break;
                    case 'highestBuy':
                        aVal = aOrderDetails?.buyOrders?.length > 0
                            ? Math.max(...aOrderDetails.buyOrders.map(o => o.priceThreshold))
                            : -Infinity;
                        bVal = bOrderDetails?.buyOrders?.length > 0
                            ? Math.max(...bOrderDetails.buyOrders.map(o => o.priceThreshold))
                            : -Infinity;
                        break;
                    case 'sellOrders':
                        aVal = a.sellOrders || 0;
                        bVal = b.sellOrders || 0;
                        break;
                    case 'buyOrders':
                        aVal = a.buyOrders || 0;
                        bVal = b.buyOrders || 0;
                        break;
                    case 'totalOrders':
                        aVal = a.totalOrders || 0;
                        bVal = b.totalOrders || 0;
                        break;
                    default:
                        aVal = a.tier || 0;
                        bVal = b.tier || 0;
                }

                // Apply sort direction
                if (typeof aVal === 'string') {
                    return itemSortDirection === 'asc'
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                } else {
                    return itemSortDirection === 'asc'
                        ? aVal - bVal
                        : bVal - aVal;
                }
            });

            // Check if any items remain after filtering
            if (items.length === 0) {
                container.innerHTML = '<div class="no-orders-message">No items match the current filters.</div>';
                return;
            }

            const getSortIndicator = (column) => {
                if (itemSortColumn === column) {
                    return itemSortDirection === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
                }
                return '';
            };

            const tableHtml = `
                <table class="market-table">
                    <thead>
                        <tr>
                            <th onclick="sortItemTable('name')" style="cursor: pointer;">Item Name${getSortIndicator('name')}</th>
                            <th onclick="sortItemTable('tier')" style="cursor: pointer;">Tier${getSortIndicator('tier')}</th>
                            <th onclick="sortItemTable('category')" style="cursor: pointer;">Category${getSortIndicator('category')}</th>
                            <th onclick="sortItemTable('lowestSell')" style="cursor: pointer;">Lowest Sell${getSortIndicator('lowestSell')}</th>
                            <th onclick="sortItemTable('highestBuy')" style="cursor: pointer;">Highest Buy${getSortIndicator('highestBuy')}</th>
                            <th onclick="sortItemTable('sellOrders')" style="cursor: pointer;">Sell Orders${getSortIndicator('sellOrders')}</th>
                            <th onclick="sortItemTable('buyOrders')" style="cursor: pointer;">Buy Orders${getSortIndicator('buyOrders')}</th>
                            <th onclick="sortItemTable('totalOrders')" style="cursor: pointer;">Total Orders${getSortIndicator('totalOrders')}</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${items.map(item => {
                            const prevItem = previousItems.get(item.id);
                            let sellOrdersHtml = item.sellOrders;
                            let buyOrdersHtml = item.buyOrders;
                            let totalOrdersHtml = item.totalOrders;

                            if (prevItem) {
                                if (item.sellOrders > prevItem.sellOrders) {
                                    sellOrdersHtml += ` <span class="change-indicator positive">+${item.sellOrders - prevItem.sellOrders}</span>`;
                                } else if (item.sellOrders < prevItem.sellOrders) {
                                    sellOrdersHtml += ` <span class="change-indicator negative">${item.sellOrders - prevItem.sellOrders}</span>`;
                                }
                                if (item.buyOrders > prevItem.buyOrders) {
                                    buyOrdersHtml += ` <span class="change-indicator positive">+${item.buyOrders - prevItem.buyOrders}</span>`;
                                } else if (item.buyOrders < prevItem.buyOrders) {
                                    buyOrdersHtml += ` <span class="change-indicator negative">${item.buyOrders - prevItem.buyOrders}</span>`;
                                }
                                if (item.totalOrders > prevItem.totalOrders) {
                                    totalOrdersHtml += ` <span class="change-indicator positive">+${item.totalOrders - prevItem.totalOrders}</span>`;
                                } else if (item.totalOrders < prevItem.totalOrders) {
                                    totalOrdersHtml += ` <span class="change-indicator negative">${item.totalOrders - prevItem.totalOrders}</span>`;
                                }
                            } else if (previousItems.size > 0) {
                                totalOrdersHtml += ` <span class="change-indicator new">NEW</span>`;
                            }

                            // Get order details for this item to find lowest sell and highest buy
                            const orderDetails = currentOrderDetails && currentOrderDetails[item.id];
                            let lowestSellHtml = '-';
                            let highestBuyHtml = '-';

                            if (orderDetails) {
                                // Find lowest sell order
                                if (orderDetails.sellOrders && orderDetails.sellOrders.length > 0) {
                                    const lowestSell = orderDetails.sellOrders.reduce((min, order) =>
                                        order.priceThreshold < min.priceThreshold ? order : min
                                    );
                                    lowestSellHtml = `
                                        <div style="font-weight: bold; color: #f87171;">${Number(lowestSell.priceThreshold).toLocaleString()} hex</div>
                                        <div style="font-size: 11px; color: #b0b0b0;">${escapeHtml(lowestSell.claimName)}</div>
                                    `;
                                }

                                // Find highest buy order
                                if (orderDetails.buyOrders && orderDetails.buyOrders.length > 0) {
                                    const highestBuy = orderDetails.buyOrders.reduce((max, order) =>
                                        order.priceThreshold > max.priceThreshold ? order : max
                                    );
                                    highestBuyHtml = `
                                        <div style="font-weight: bold; color: #4ade80;">${Number(highestBuy.priceThreshold).toLocaleString()} hex</div>
                                        <div style="font-size: 11px; color: #b0b0b0;">${escapeHtml(highestBuy.claimName)}</div>
                                    `;
                                }
                            }

                            const rowClass = (prevItem && (item.sellOrders !== prevItem.sellOrders || item.buyOrders !== prevItem.buyOrders)) ? 'highlighted' : '';
                            const itemCategory = item.tag || item.category || 'Unknown';

                            return `
                                <tr class="${rowClass}" onclick="viewItemDetails('${item.id}', '${escapeHtml(item.name)}')">
                                    <td><a href="https://bitjita.com/market/item/${item.id}" target="_blank" style="color: #4a9eff; text-decoration: none;">${escapeHtml(item.name)}</a></td>
                                    <td>${item.tier}</td>
                                    <td>${escapeHtml(itemCategory)}</td>
                                    <td>${lowestSellHtml}</td>
                                    <td>${highestBuyHtml}</td>
                                    <td>${sellOrdersHtml}</td>
                                    <td>${buyOrdersHtml}</td>
                                    <td>${totalOrdersHtml}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;

            container.innerHTML = tableHtml;

            // Update previous items map
            previousItems.clear();
            items.forEach(item => {
                previousItems.set(item.id, { ...item });
            });
        }

        function setViewMode(mode) {
            viewMode = mode;
            document.getElementById('viewByClaimBtn').classList.toggle('active', mode === 'claim');
            document.getElementById('viewByItemBtn').classList.toggle('active', mode === 'item');

            if (currentState) {
                updateMarketTable({ currentState });
            }
        }

        function sortItemTable(column) {
            // Toggle direction if clicking same column, otherwise default to ascending
            if (itemSortColumn === column) {
                itemSortDirection = itemSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                itemSortColumn = column;
                itemSortDirection = 'asc';
            }

            // Re-render table with new sort
            if (currentState) {
                updateMarketTable({ currentState });
            }
        }

        function toggleClaimSection(header) {
            const orders = header.nextElementSibling;
            orders.classList.toggle('collapsed');
        }

        function updateChangeLog(data) {
            const changeLog = document.getElementById('changeLog');

            // Get order type filters
            const showBuyOrders = document.getElementById('showBuyOrders')?.checked ?? true;
            const showSellOrders = document.getElementById('showSellOrders')?.checked ?? true;

            if (!data.changes || data.changes.length === 0) {
                changeLog.innerHTML = '<div class="empty-state">No changes detected yet. Changes will appear here when market orders are added, removed, or modified.</div>';
                return;
            }

            // Reverse to show newest first
            const entries = [];
            for (let i = data.changes.length - 1; i >= 0; i--) {
                const entry = data.changes[i];

                entry.changes.forEach(change => {
                    // Filter by selected claim if one is selected
                    if (selectedClaim) {
                        const hasMatchingClaim = changeInvolvesClaim(change, selectedClaim);
                        if (!hasMatchingClaim) {
                            return; // Skip this change
                        }
                    }

                    let className = 'change-entry';
                    let changeTypeBadge = '';
                    let changeSummary = '';
                    let itemMeta = '';

                    // Get item metadata
                    const itemTier = change.tier || '';
                    const itemRarity = (change.rarity || change.rarityStr || '').toLowerCase();

                    if (itemTier) {
                        itemMeta += `<span class="item-tier-badge">Tier ${itemTier}</span>`;
                    }
                    if (itemRarity) {
                        itemMeta += `<span class="item-rarity-badge ${itemRarity}">${escapeHtml(itemRarity.charAt(0).toUpperCase() + itemRarity.slice(1))}</span>`;
                    }

                    if (change.type === 'new_item') {
                        className += ' new-item';
                        changeTypeBadge = '<span class="change-type-badge new">New Item</span>';
                        changeSummary = `<span class="change-delta">${change.totalOrders} total orders (${change.sellOrders} sell, ${change.buyOrders} buy)</span>`;
                    } else if (change.type === 'order_change') {
                        if (change.delta.totalOrders > 0) {
                            className += ' order-increase';
                        } else if (change.delta.totalOrders < 0) {
                            className += ' order-decrease';
                        } else {
                            className += ' order-change';
                        }

                        changeTypeBadge = '<span class="change-type-badge updated">Updated</span>';

                        const deltaHtml = [];
                        if (change.delta.sellOrders !== 0) {
                            const deltaClass = change.delta.sellOrders > 0 ? 'positive' : 'negative';
                            deltaHtml.push(`<span class="change-delta ${deltaClass}">Sell: ${change.delta.sellOrders > 0 ? '+' : ''}${change.delta.sellOrders}</span>`);
                        }
                        if (change.delta.buyOrders !== 0) {
                            const deltaClass = change.delta.buyOrders > 0 ? 'positive' : 'negative';
                            deltaHtml.push(`<span class="change-delta ${deltaClass}">Buy: ${change.delta.buyOrders > 0 ? '+' : ''}${change.delta.buyOrders}</span>`);
                        }
                        if (deltaHtml.length === 0) {
                            deltaHtml.push(`<span class="change-delta">Order details changed</span>`);
                        }
                        deltaHtml.push(`<span class="change-delta" style="color: #808080;">Total: ${change.current.totalOrders}</span>`);
                        changeSummary = deltaHtml.join('');
                    } else if (change.type === 'item_removed') {
                        className += ' item-removed';
                        changeTypeBadge = '<span class="change-type-badge removed">Removed</span>';
                        changeSummary = `<span class="change-delta negative">All ${change.previous.totalOrders} orders removed</span>`;
                    }

                    // Build detailed order information
                    let orderDetails = '';
                    let hasDetailedDiff = false;

                    // Check if we have detailed added/removed orders
                    if (change.addedOrders) {
                        const addedSellOrders = change.addedOrders.sellOrders || [];
                        const addedBuyOrders = change.addedOrders.buyOrders || [];

                        [...addedSellOrders, ...addedBuyOrders].forEach(order => {
                            const orderType = addedSellOrders.includes(order) ? 'sell' : 'buy';
                            // Apply order type filter
                            if ((orderType === 'buy' && !showBuyOrders) || (orderType === 'sell' && !showSellOrders)) {
                                return;
                            }
                            hasDetailedDiff = true;
                            orderDetails += `
                                <div class="individual-order ${orderType}-order">
                                    <div class="order-primary-info">
                                        <span class="order-type-badge ${orderType}">${orderType.toUpperCase()}</span>
                                        <span class="action-badge added">Added</span>
                                        <span class="claim-badge">${escapeHtml(order.claimName || 'Unknown Claim')}</span>
                                        <span class="owner-badge">${escapeHtml(order.ownerName || 'Unknown')}</span>
                                    </div>
                                    <div class="order-price-info">
                                        <span>Qty: <span class="order-qty-highlight">${Number(order.quantity).toLocaleString()}</span></span>
                                        <span>Price: <span class="order-price-highlight">${Number(order.priceThreshold).toLocaleString()} hex</span></span>
                                    </div>
                                </div>
                            `;
                        });
                    }
                    if (change.removedOrders) {
                        const removedSellOrders = change.removedOrders.sellOrders || [];
                        const removedBuyOrders = change.removedOrders.buyOrders || [];

                        [...removedSellOrders, ...removedBuyOrders].forEach(order => {
                            const orderType = removedSellOrders.includes(order) ? 'sell' : 'buy';
                            // Apply order type filter
                            if ((orderType === 'buy' && !showBuyOrders) || (orderType === 'sell' && !showSellOrders)) {
                                return;
                            }
                            hasDetailedDiff = true;
                            orderDetails += `
                                <div class="individual-order ${orderType}-order">
                                    <div class="order-primary-info">
                                        <span class="order-type-badge ${orderType}">${orderType.toUpperCase()}</span>
                                        <span class="action-badge removed">Removed</span>
                                        <span class="claim-badge">${escapeHtml(order.claimName || 'Unknown Claim')}</span>
                                        <span class="owner-badge">${escapeHtml(order.ownerName || 'Unknown')}</span>
                                    </div>
                                    <div class="order-price-info">
                                        <span>Qty: <span class="order-qty-highlight">${Number(order.quantity).toLocaleString()}</span></span>
                                        <span>Price: <span class="order-price-highlight">${Number(order.priceThreshold).toLocaleString()} hex</span></span>
                                    </div>
                                </div>
                            `;
                        });
                    }

                    // FALLBACK: If no detailed diff available, show current orders from orderDetails
                    if (!hasDetailedDiff && change.orderDetails && (change.orderDetails.sellOrders?.length > 0 || change.orderDetails.buyOrders?.length > 0)) {
                        orderDetails += `<div style="margin-top: 8px; padding: 8px; background-color: rgba(74, 158, 255, 0.1); border-radius: 4px; font-size: 11px; color: #b0b0b0;">
                            ‚ÑπÔ∏è Current market state (exact changes pending next full sync):
                        </div>`;

                        // Show current sell orders
                        const currentSellOrders = change.orderDetails.sellOrders || [];
                        const currentBuyOrders = change.orderDetails.buyOrders || [];

                        currentSellOrders.forEach(order => {
                            if (!showSellOrders) return;
                            orderDetails += `
                                <div class="individual-order sell-order">
                                    <div class="order-primary-info">
                                        <span class="order-type-badge sell">SELL</span>
                                        <span class="claim-badge">${escapeHtml(order.claimName || 'Unknown Claim')}</span>
                                        <span class="owner-badge">${escapeHtml(order.ownerName || order.ownerUsername || 'Unknown')}</span>
                                    </div>
                                    <div class="order-price-info">
                                        <span>Qty: <span class="order-qty-highlight">${Number(order.quantity).toLocaleString()}</span></span>
                                        <span>Price: <span class="order-price-highlight">${Number(order.priceThreshold).toLocaleString()} hex</span></span>
                                    </div>
                                </div>
                            `;
                        });

                        currentBuyOrders.forEach(order => {
                            if (!showBuyOrders) return;
                            orderDetails += `
                                <div class="individual-order buy-order">
                                    <div class="order-primary-info">
                                        <span class="order-type-badge buy">BUY</span>
                                        <span class="claim-badge">${escapeHtml(order.claimName || 'Unknown Claim')}</span>
                                        <span class="owner-badge">${escapeHtml(order.ownerName || order.ownerUsername || 'Unknown')}</span>
                                    </div>
                                    <div class="order-price-info">
                                        <span>Qty: <span class="order-qty-highlight">${Number(order.quantity).toLocaleString()}</span></span>
                                        <span>Price: <span class="order-price-highlight">${Number(order.priceThreshold).toLocaleString()} hex</span></span>
                                    </div>
                                </div>
                            `;
                        });
                    }

                    // FALLBACK 2: If no orderDetails but we have stats, show those
                    if (!hasDetailedDiff && orderDetails === '' && change.orderDetails?.stats) {
                        const stats = change.orderDetails.stats;
                        if (stats.lowestSell || stats.highestBuy || stats.totalAvailableSell || stats.totalAvailableBuy) {
                            orderDetails += `<div style="margin-top: 8px; padding: 8px; background-color: rgba(74, 158, 255, 0.1); border-radius: 4px; font-size: 12px; color: #e0e0e0;">
                                üìä Market Stats:<br>
                                ${stats.lowestSell ? `Lowest Sell: ${Number(stats.lowestSell).toLocaleString()} hex` : ''}
                                ${stats.lowestSell && stats.highestBuy ? ' | ' : ''}
                                ${stats.highestBuy ? `Highest Buy: ${Number(stats.highestBuy).toLocaleString()} hex` : ''}<br>
                                ${stats.totalAvailableSell ? `Available to Sell: ${Number(stats.totalAvailableSell).toLocaleString()}` : ''}
                                ${stats.totalAvailableSell && stats.totalAvailableBuy ? ' | ' : ''}
                                ${stats.totalAvailableBuy ? `Available to Buy: ${Number(stats.totalAvailableBuy).toLocaleString()}` : ''}
                            </div>`;
                        }
                    }

                    entries.push(`
                        <div class="${className}">
                            <div class="change-header">
                                <div class="change-main-info">
                                    <div class="change-item-name">
                                        <a href="https://bitjita.com/market/item/${change.itemId}" target="_blank" class="change-item-link">${escapeHtml(change.itemName)}</a>
                                        <div class="change-item-meta">
                                            ${itemMeta}
                                        </div>
                                    </div>
                                    <div class="change-summary">
                                        ${changeTypeBadge}
                                        ${changeSummary}
                                    </div>
                                </div>
                                <div class="change-timestamp">${new Date(entry.timestamp).toLocaleString()}</div>
                            </div>
                            ${orderDetails ? `<div class="change-order-details">${orderDetails}</div>` : ''}
                        </div>
                    `);
                });
            }

            if (entries.length === 0 && selectedClaim) {
                changeLog.innerHTML = `<div class="empty-state">No changes found for claim "${escapeHtml(selectedClaim)}". Try selecting "All Claims" to see all changes.</div>`;
            } else if (entries.length === 0) {
                changeLog.innerHTML = '<div class="empty-state">No changes detected yet. Changes will appear here when market orders are added, removed, or modified.</div>';
            } else {
                changeLog.innerHTML = entries.join('');
            }
        }

        function changeInvolvesClaim(change, claimName) {
            // Check if change involves the specified claim
            if (change.orderDetails) {
                const allOrders = [...(change.orderDetails.sellOrders || []), ...(change.orderDetails.buyOrders || [])];
                if (allOrders.some(o => o.claimName === claimName)) {
                    return true;
                }
            }
            if (change.addedOrders) {
                const allAdded = [...(change.addedOrders.sellOrders || []), ...(change.addedOrders.buyOrders || [])];
                if (allAdded.some(o => o.claimName === claimName)) {
                    return true;
                }
            }
            if (change.removedOrders) {
                const allRemoved = [...(change.removedOrders.sellOrders || []), ...(change.removedOrders.buyOrders || [])];
                if (allRemoved.some(o => o.claimName === claimName)) {
                    return true;
                }
            }
            return false;
        }

        function getClaimsFromOrders(orders) {
            const claims = new Set();
            [...(orders.sellOrders || []), ...(orders.buyOrders || [])].forEach(o => {
                if (o.claimName) {
                    // If filtering by claim, only show that claim
                    if (!selectedClaim || o.claimName === selectedClaim) {
                        claims.add(o.claimName);
                    }
                }
            });
            return Array.from(claims);
        }

        function updateStatusBar(data) {
            // Update last update time
            if (data.lastUpdate) {
                const lastUpdate = new Date(data.lastUpdate);
                const now = new Date();
                const diffMinutes = Math.floor((now - lastUpdate) / 60000);

                if (diffMinutes < 1) {
                    document.getElementById('lastUpdateText').textContent = 'Just now';
                } else if (diffMinutes < 60) {
                    document.getElementById('lastUpdateText').textContent = `${diffMinutes}m ago`;
                } else {
                    document.getElementById('lastUpdateText').textContent = lastUpdate.toLocaleTimeString();
                }
            }

            // Update total changes
            document.getElementById('totalChanges').textContent = data.changeCount || 0;

            // Update item count
            const itemCount = data.currentState?.items?.length || 0;
            document.getElementById('itemCount').textContent = itemCount;
        }

        function updateStatus(text, status) {
            document.getElementById('statusText').textContent = text;
            const indicator = document.getElementById('statusIndicator');
            indicator.className = `status-indicator ${status}`;
        }

        function showError(message) {
            const container = document.getElementById('errorContainer');
            container.innerHTML = `
                <div class="error-message">
                    <strong>Error:</strong> ${escapeHtml(message)}
                </div>
            `;
        }

        function clearError() {
            document.getElementById('errorContainer').innerHTML = '';
        }

        function clearHighlights() {
            document.querySelectorAll('.highlighted').forEach(el => {
                el.classList.remove('highlighted');
            });
        }

        // ==========================================
        // ITEM DETAILS
        // ==========================================
        function viewItemDetails(itemId, itemName) {
            window.open(`https://bitjita.com/market/item/${itemId}`, '_blank');
        }

        // ==========================================
        // CLAIM FILTER
        // ==========================================
        function initClaimFilter() {
            const input = document.getElementById('claimFilterInput');
            const dropdown = document.getElementById('claimDropdown');

            // Show dropdown on focus
            input.addEventListener('focus', () => {
                updateClaimDropdown(input.value);
                dropdown.classList.add('show');
            });

            // Filter on input
            input.addEventListener('input', (e) => {
                updateClaimDropdown(e.target.value);
                dropdown.classList.add('show');
            });

            // Hide dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.claim-filter-container')) {
                    dropdown.classList.remove('show');
                }
            });

            // Keyboard navigation
            input.addEventListener('keydown', (e) => {
                const items = dropdown.querySelectorAll('.claim-dropdown-item');
                const selected = dropdown.querySelector('.claim-dropdown-item.selected');
                let index = Array.from(items).indexOf(selected);

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (index < items.length - 1) {
                        items[index]?.classList.remove('selected');
                        items[index + 1]?.classList.add('selected');
                        items[index + 1]?.scrollIntoView({ block: 'nearest' });
                    }
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (index > 0) {
                        items[index]?.classList.remove('selected');
                        items[index - 1]?.classList.add('selected');
                        items[index - 1]?.scrollIntoView({ block: 'nearest' });
                    }
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selected) {
                        selected.click();
                    }
                } else if (e.key === 'Escape') {
                    dropdown.classList.remove('show');
                    input.blur();
                }
            });
        }

        function updateClaimDropdown(filter = '') {
            const dropdown = document.getElementById('claimDropdown');
            const filterLower = filter.toLowerCase();

            // Build list of claims
            let claimsList = Array.from(allClaims.entries())
                .map(([name, data]) => ({ name, ...data }))
                .sort((a, b) => b.orderCount - a.orderCount);

            // Filter by search term
            if (filterLower) {
                claimsList = claimsList.filter(c =>
                    c.name.toLowerCase().includes(filterLower)
                );
            }

            // Build dropdown HTML
            let html = `
                <div class="claim-dropdown-item all-claims" onclick="selectClaim(null)">
                    <span class="claim-name">All Claims</span>
                    <span class="claim-orders">(${allClaims.size} claims)</span>
                </div>
            `;

            claimsList.slice(0, 50).forEach((claim, index) => {
                html += `
                    <div class="claim-dropdown-item" onclick="selectClaim('${escapeHtml(claim.name)}')">
                        <span class="claim-name">${escapeHtml(claim.name)}</span>
                        <span class="claim-orders">${claim.orderCount} orders</span>
                    </div>
                `;
            });

            if (claimsList.length === 0 && filterLower) {
                html += `<div class="claim-dropdown-item" style="color: #808080; cursor: default;">No claims found</div>`;
            }

            dropdown.innerHTML = html;
        }

        function selectClaim(claimName) {
            selectedClaim = claimName;
            const input = document.getElementById('claimFilterInput');
            const dropdown = document.getElementById('claimDropdown');
            const clearBtn = document.getElementById('claimFilterClear');

            if (claimName) {
                input.value = claimName;
                clearBtn.style.display = 'block';
            } else {
                input.value = '';
                clearBtn.style.display = 'none';
            }

            dropdown.classList.remove('show');

            // Re-render table and changes with filter applied
            if (currentState) {
                updateMarketTable({ currentState });
            }
            if (lastChangesData) {
                updateChangeLog(lastChangesData);
            }
        }

        function clearClaimFilter() {
            selectClaim(null);
            document.getElementById('claimFilterInput').focus();
        }

        function extractClaimsFromOrderDetails(orderDetails) {
            // Extract unique claims from current order details
            if (!orderDetails || Object.keys(orderDetails).length === 0) return;

            Object.values(orderDetails).forEach(details => {
                [...(details.sellOrders || []), ...(details.buyOrders || [])].forEach(order => {
                    if (order.claimName) {
                        const existing = allClaims.get(order.claimName);
                        if (!existing) {
                            allClaims.set(order.claimName, {
                                claimEntityId: order.claimEntityId,
                                orderCount: 0
                            });
                        }
                    }
                });
            });
        }

        function countClaimOrdersFromDetails(orderDetails) {
            // Reset counts
            allClaims.forEach((data, name) => {
                data.orderCount = 0;
            });

            if (!orderDetails || Object.keys(orderDetails).length === 0) return;

            // Count orders per claim
            Object.values(orderDetails).forEach(details => {
                [...(details.sellOrders || []), ...(details.buyOrders || [])].forEach(order => {
                    if (order.claimName) {
                        const claim = allClaims.get(order.claimName);
                        if (claim) {
                            claim.orderCount++;
                        } else {
                            allClaims.set(order.claimName, {
                                claimEntityId: order.claimEntityId,
                                orderCount: 1
                            });
                        }
                    }
                });
            });
        }

        // ==========================================
        // ORDER TYPE FILTER
        // ==========================================
        function applyOrderTypeFilter() {
            // Re-render table and changes with filter applied
            if (currentState) {
                updateMarketTable({ currentState });
            }
            if (lastChangesData) {
                updateChangeLog(lastChangesData);
            }
        }

        // ==========================================
        // ITEM FILTER
        // ==========================================
        function applyItemFilter() {
            const input = document.getElementById('itemFilterInput');
            const clearBtn = document.getElementById('itemFilterClear');

            if (input.value) {
                clearBtn.style.display = 'block';
            } else {
                clearBtn.style.display = 'none';
            }

            // Re-render table with filter applied
            if (currentState) {
                updateMarketTable({ currentState });
            }
        }

        function clearItemFilter() {
            const input = document.getElementById('itemFilterInput');
            input.value = '';
            applyItemFilter();
        }

        // ==========================================
        // MIN HEX FILTER
        // ==========================================
        function applyMinHexFilter() {
            const input = document.getElementById('minHexFilter');
            const clearBtn = document.getElementById('minHexClear');

            if (input.value && parseFloat(input.value) > 0) {
                clearBtn.style.display = 'inline-block';
            } else {
                clearBtn.style.display = 'none';
            }

            // Re-render table with filter applied
            if (currentState) {
                updateMarketTable({ currentState });
            }
        }

        function clearMinHexFilter() {
            const input = document.getElementById('minHexFilter');
            input.value = '';
            applyMinHexFilter();
        }

        // ==========================================
        // TIER FILTER
        // ==========================================
        function toggleTierDropdown() {
            const dropdown = document.getElementById('tierDropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        }

        function updateTierSelection() {
            const checkboxes = document.querySelectorAll('.tier-checkbox');
            const allCheckbox = document.getElementById('tierAll');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);

            allCheckbox.checked = allChecked;
            updateTierLabel();
        }

        function toggleAllTiers() {
            const allCheckbox = document.getElementById('tierAll');
            const checkboxes = document.querySelectorAll('.tier-checkbox');

            checkboxes.forEach(cb => {
                cb.checked = allCheckbox.checked;
            });
            updateTierLabel();
        }

        function updateTierLabel() {
            const checkboxes = document.querySelectorAll('.tier-checkbox:checked');
            const label = document.getElementById('tierFilterLabel');

            if (checkboxes.length === 10) {
                label.textContent = 'All Tiers';
            } else if (checkboxes.length === 0) {
                label.textContent = 'No Tiers';
            } else if (checkboxes.length === 1) {
                label.textContent = `Tier ${checkboxes[0].value}`;
            } else {
                label.textContent = `${checkboxes.length} Tiers`;
            }
        }

        function applyTierFilter() {
            selectedTiers.clear();
            document.querySelectorAll('.tier-checkbox:checked').forEach(cb => {
                selectedTiers.add(parseInt(cb.value));
            });

            document.getElementById('tierDropdown').style.display = 'none';

            // Re-render table with filter applied
            if (currentState) {
                updateMarketTable({ currentState });
            }
        }

        function clearTierFilter() {
            selectedTiers.clear();
            for (let i = 1; i <= 10; i++) {
                selectedTiers.add(i);
            }

            document.querySelectorAll('.tier-checkbox').forEach(cb => {
                cb.checked = true;
            });
            document.getElementById('tierAll').checked = true;
            updateTierLabel();

            document.getElementById('tierDropdown').style.display = 'none';

            // Re-render table with filter applied
            if (currentState) {
                updateMarketTable({ currentState });
            }
        }

        // ==========================================
        // CATEGORY FILTER
        // ==========================================
        function populateCategoryFilter() {
            const select = document.getElementById('categoryFilter');
            const currentValue = selectedCategory;

            // Extract categories from current orders
            availableCategories.clear();
            claimOrdersMap.forEach(claimData => {
                claimData.orderGroups.forEach(group => {
                    if (group.category && group.category !== 'Unknown') {
                        availableCategories.add(group.category);
                    }
                });
            });

            // Sort alphabetically
            const sortedCategories = Array.from(availableCategories).sort();

            // Build options
            let html = '<option value="">All Categories</option>';
            sortedCategories.forEach(category => {
                const selected = category === currentValue ? 'selected' : '';
                html += `<option value="${escapeHtml(category)}" ${selected}>${escapeHtml(category)}</option>`;
            });

            select.innerHTML = html;
        }

        function applyCategoryFilter() {
            const select = document.getElementById('categoryFilter');
            selectedCategory = select.value;

            // Re-render table with filter applied
            if (currentState) {
                updateMarketTable({ currentState });
            }
        }

        // ==========================================
        // UTILITIES
        // ==========================================
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }

        // ==========================================
        // START
        // ==========================================
        window.addEventListener('DOMContentLoaded', init);

        // ==========================================
        // UI VERSION TOGGLE
        // ==========================================
        function initVersionToggle() {
            const toggle = document.getElementById('uiVersionToggle');
            const sharedStyles = document.getElementById('sharedStyles');
            const savedVersion = localStorage.getItem('bitcraftMarketHelper_uiVersion');

            if (savedVersion === 'enhanced') {
                toggle.checked = true;
                sharedStyles.disabled = false;
                document.body.classList.add('enhanced-ui');
            }

            toggle.addEventListener('change', function() {
                if (this.checked) {
                    sharedStyles.disabled = false;
                    document.body.classList.add('enhanced-ui');
                    localStorage.setItem('bitcraftMarketHelper_uiVersion', 'enhanced');
                } else {
                    sharedStyles.disabled = true;
                    document.body.classList.remove('enhanced-ui');
                    localStorage.setItem('bitcraftMarketHelper_uiVersion', 'classic');
                }
            });
        }

        window.addEventListener('DOMContentLoaded', initVersionToggle);
    </script>
</body>
</html>
